<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ResourceDAO.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Entando Plugin: CMS</a> &gt; <a href="index.source.html" class="el_package">com.agiletec.plugins.jacms.aps.system.services.resource</a> &gt; <span class="el_source">ResourceDAO.java</span></div><h1>ResourceDAO.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-Present Entando Inc. (http://www.entando.com) All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 */
package com.agiletec.plugins.jacms.aps.system.services.resource;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.entando.entando.ent.util.EntLogging.EntLogger;
import org.entando.entando.ent.util.EntLogging.EntLogFactory;

import com.agiletec.aps.system.common.AbstractSearcherDAO;
import com.agiletec.aps.system.common.FieldSearchFilter;
import org.entando.entando.ent.exception.EntException;
import com.agiletec.aps.system.services.category.Category;
import com.agiletec.aps.system.services.category.ICategoryManager;
import com.agiletec.plugins.jacms.aps.system.services.resource.model.ResourceInterface;
import com.agiletec.plugins.jacms.aps.system.services.resource.model.ResourceRecordVO;
import java.util.Arrays;
import java.util.Date;
import org.apache.commons.lang3.StringUtils;
import org.entando.entando.aps.system.services.cache.ICacheInfoManager;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;

/**
 * Data Access Object per gli oggetti risorsa.
 *
 * @author E.Santoboni - W.Ambu
 */
<span class="fc" id="L48">public class ResourceDAO extends AbstractSearcherDAO implements IResourceDAO {</span>

<span class="fc" id="L50">    private static final EntLogger logger = EntLogFactory.getSanitizedLogger(ResourceDAO.class);</span>
    
    private ICategoryManager categoryManager;

<span class="fc" id="L54">    private final String LOAD_RESOURCE_VO</span>
            = &quot;SELECT restype, descr, maingroup, resourcexml, masterfilename, creationdate, lastmodified, owner, folderpath FROM resources WHERE resid = ? &quot;;

<span class="fc" id="L57">    private final String ADD_RESOURCE</span>
            = &quot;INSERT INTO resources (resid, restype, descr, maingroup, resourcexml, masterfilename, creationdate, lastmodified, owner, folderpath) &quot;
            + &quot;VALUES ( ? , ? , ? , ? , ? , ? , ? , ? , ?, ?)&quot;;

<span class="fc" id="L61">    private final String UPDATE_RESOURCE</span>
            = &quot;UPDATE resources SET restype = ? , descr = ? , maingroup = ? , resourcexml = ? , masterfilename = ? , lastmodified = ?, folderpath = ? WHERE resid = ? &quot;;

<span class="fc" id="L64">    private final String DELETE_CONTENTS_REFERENCE</span>
            = &quot;DELETE FROM contentrelations WHERE refresource = ? &quot;;

<span class="fc" id="L67">    private final String DELETE_RESOURCE</span>
            = &quot;DELETE FROM resources WHERE resid = ? &quot;;

<span class="fc" id="L70">    private final String ADD_RESOURCE_REL_RECORD</span>
            = &quot;INSERT INTO resourcerelations (resid, refcategory) VALUES ( ? , ? )&quot;;

<span class="fc" id="L73">    private final String DELETE_RESOURCE_REL_RECORD</span>
            = &quot;DELETE FROM resourcerelations WHERE resid = ? &quot;;

    protected ICategoryManager getCategoryManager() {
<span class="fc" id="L77">        return categoryManager;</span>
    }

    public void setCategoryManager(ICategoryManager categoryManager) {
<span class="fc" id="L81">        this.categoryManager = categoryManager;</span>
<span class="fc" id="L82">    }</span>

    /**
     * Carica una risorsa nel db.
     *
     * @param resource La risorsa da caricare nel db.
     */
    @Override
    public void addResource(ResourceInterface resource) {
<span class="fc" id="L91">        Connection conn = null;</span>
        try {
<span class="fc" id="L93">            conn = this.getConnection();</span>
<span class="fc" id="L94">            conn.setAutoCommit(false);</span>
<span class="fc" id="L95">            this.executeAddResource(resource, conn);</span>
<span class="fc" id="L96">            conn.commit();</span>
<span class="nc" id="L97">        } catch (Throwable t) {</span>
<span class="nc" id="L98">            this.executeRollback(conn);</span>
<span class="nc" id="L99">            logger.error(&quot;Error adding resource&quot;, t);</span>
<span class="nc" id="L100">            throw new RuntimeException(&quot;Error adding resource&quot;, t);</span>
        } finally {
<span class="fc" id="L102">            closeConnection(conn);</span>
        }
<span class="fc" id="L104">    }</span>

    protected void executeAddResource(ResourceInterface resource, Connection conn) throws EntException {
<span class="fc" id="L107">        this.addResourceRecord(resource, conn);</span>
<span class="fc" id="L108">        this.addCategoryRelationsRecord(resource, conn);</span>
<span class="fc" id="L109">    }</span>

    protected void addResourceRecord(ResourceInterface resource, Connection conn) throws EntException {
<span class="fc" id="L112">        PreparedStatement stat = null;</span>
        try {
<span class="fc" id="L114">            stat = conn.prepareStatement(ADD_RESOURCE);</span>
<span class="fc" id="L115">            stat.setString(1, resource.getId());</span>
<span class="fc" id="L116">            stat.setString(2, resource.getType());</span>
<span class="fc" id="L117">            stat.setString(3, resource.getDescription().trim());</span>
<span class="fc" id="L118">            stat.setString(4, resource.getMainGroup());</span>
<span class="fc" id="L119">            stat.setString(5, resource.getXML());</span>
<span class="fc" id="L120">            stat.setString(6, resource.getMasterFileName().trim());</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            Date creationDate = (null != resource.getCreationDate())</span>
<span class="fc" id="L122">                    ? resource.getCreationDate() : new Date();</span>
<span class="fc" id="L123">            stat.setTimestamp(7, new java.sql.Timestamp(creationDate.getTime()));</span>
<span class="fc" id="L124">            stat.setTimestamp(8, new java.sql.Timestamp(creationDate.getTime()));</span>
<span class="fc" id="L125">            stat.setString(9, resource.getOwner());</span>
<span class="fc" id="L126">            stat.setString(10, resource.getFolderPath());</span>
<span class="fc" id="L127">            stat.executeUpdate();</span>
<span class="nc" id="L128">        } catch (Throwable t) {</span>
<span class="nc" id="L129">            logger.error(&quot;Error adding resource record&quot;, t);</span>
<span class="nc" id="L130">            throw new RuntimeException(&quot;Error adding resource record&quot;, t);</span>
        } finally {
<span class="fc" id="L132">            closeDaoResources(null, stat);</span>
        }
<span class="fc" id="L134">    }</span>

    /**
     * Aggiorna una risorsa nel database.
     *
     * @param resource La risorsa da aggiornare nel db.
     */
    @Override
    @CacheEvict(value = ICacheInfoManager.DEFAULT_CACHE_NAME, key = &quot;'jacms_resource_'.concat(#resource.id)&quot;, condition = &quot;null != #resource&quot;)
    public void updateResource(ResourceInterface resource) {
<span class="fc" id="L144">        Connection conn = null;</span>
        try {
<span class="fc" id="L146">            conn = this.getConnection();</span>
<span class="fc" id="L147">            conn.setAutoCommit(false);</span>
<span class="fc" id="L148">            this.executeUpdateResource(resource, conn);</span>
<span class="fc" id="L149">            conn.commit();</span>
<span class="nc" id="L150">        } catch (Throwable t) {</span>
<span class="nc" id="L151">            this.executeRollback(conn);</span>
<span class="nc" id="L152">            logger.error(&quot;Error updating resource&quot;, t);</span>
<span class="nc" id="L153">            throw new RuntimeException(&quot;Error updating resource&quot;, t);</span>
        } finally {
<span class="fc" id="L155">            closeConnection(conn);</span>
        }
<span class="fc" id="L157">    }</span>

    protected void executeUpdateResource(ResourceInterface resource, Connection conn) throws EntException {
<span class="fc" id="L160">        this.deleteRecordsById(resource.getId(), DELETE_RESOURCE_REL_RECORD, conn);</span>
<span class="fc" id="L161">        this.updateResourceRecord(resource, conn);</span>
<span class="fc" id="L162">        this.addCategoryRelationsRecord(resource, conn);</span>
<span class="fc" id="L163">    }</span>

    protected void updateResourceRecord(ResourceInterface resource, Connection conn) throws EntException {
<span class="fc" id="L166">        PreparedStatement stat = null;</span>
        try {
<span class="fc" id="L168">            stat = conn.prepareStatement(UPDATE_RESOURCE);</span>
<span class="fc" id="L169">            stat.setString(1, resource.getType());</span>
<span class="fc" id="L170">            stat.setString(2, resource.getDescription().trim());</span>
<span class="fc" id="L171">            stat.setString(3, resource.getMainGroup());</span>
<span class="fc" id="L172">            stat.setString(4, resource.getXML());</span>
<span class="fc" id="L173">            stat.setString(5, resource.getMasterFileName().trim());</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (null != resource.getLastModified()) {</span>
<span class="fc" id="L175">                stat.setTimestamp(6, new java.sql.Timestamp(resource.getLastModified().getTime()));</span>
            } else {
<span class="fc" id="L177">                stat.setTimestamp(6, new java.sql.Timestamp(new java.util.Date().getTime()));</span>
            }
<span class="fc" id="L179">            stat.setString(7, resource.getFolderPath());</span>
<span class="fc" id="L180">            stat.setString(8, resource.getId());</span>
<span class="fc" id="L181">            stat.executeUpdate();</span>
<span class="nc" id="L182">        } catch (Throwable t) {</span>
<span class="nc" id="L183">            logger.error(&quot;Error updating resource record&quot;, t);</span>
<span class="nc" id="L184">            throw new RuntimeException(&quot;Error updating resource record&quot;, t);</span>
        } finally {
<span class="fc" id="L186">            closeDaoResources(null, stat);</span>
        }
<span class="fc" id="L188">    }</span>

    /**
     * Cancella una risorsa dal db.
     *
     * @param id L'identificativo della risorsa da cancellare.
     */
    @Override
    @CacheEvict(value = ICacheInfoManager.DEFAULT_CACHE_NAME, key = &quot;'jacms_resource_'.concat(#id)&quot;, condition = &quot;null != #id&quot;)
    public void deleteResource(String id) {
<span class="fc" id="L198">        Connection conn = null;</span>
        try {
<span class="fc" id="L200">            conn = this.getConnection();</span>
<span class="fc" id="L201">            conn.setAutoCommit(false);</span>
<span class="fc" id="L202">            this.executeDeleteResource(id, conn);</span>
<span class="fc" id="L203">            conn.commit();</span>
<span class="nc" id="L204">        } catch (Throwable t) {</span>
<span class="nc" id="L205">            this.executeRollback(conn);</span>
<span class="nc" id="L206">            logger.error(&quot;Error deleting resource {}&quot;, id, t);</span>
<span class="nc" id="L207">            throw new RuntimeException(&quot;Error deleting resource &quot; + id, t);</span>
        } finally {
<span class="fc" id="L209">            this.closeConnection(conn);</span>
        }
<span class="fc" id="L211">    }</span>

    protected void executeDeleteResource(String resourceId, Connection conn) throws EntException {
<span class="fc" id="L214">        PreparedStatement stat = null;</span>
        try {
<span class="fc" id="L216">            this.deleteRecordsById(resourceId, DELETE_RESOURCE_REL_RECORD, conn);</span>
<span class="fc" id="L217">            this.deleteRecordsById(resourceId, DELETE_CONTENTS_REFERENCE, conn);</span>
<span class="fc" id="L218">            stat = conn.prepareStatement(DELETE_RESOURCE);</span>
<span class="fc" id="L219">            stat.setString(1, resourceId);</span>
<span class="fc" id="L220">            stat.executeUpdate();</span>
<span class="nc" id="L221">        } catch (Throwable t) {</span>
<span class="nc" id="L222">            logger.error(&quot;Error deleting resource {}&quot;, resourceId, t);</span>
<span class="nc" id="L223">            throw new RuntimeException(&quot;Error deleting resource &quot; + resourceId, t);</span>
        } finally {
<span class="fc" id="L225">            closeDaoResources(null, stat);</span>
        }
<span class="fc" id="L227">    }</span>

    /**
     * Carica una lista di identificativi di risorse in base al tipo, ad una
     * parola chiave e dalla categoria della risorsa.
     *
     * @param type Tipo di risorsa da cercare.
     * @param text Testo immesso per il raffronto con la descrizione della
     * risorsa. null o stringa vuota nel caso non si voglia ricercare le risorse
     * per parola chiave.
     * @param categoryCode Il codice della categoria delle risorse. null o
     * stringa vuota nel caso non si voglia ricercare le risorse per categoria.
     * @param groupCodes I codici dei gruppi utenti consentiti tramite il quale
     * filtrare le risorse. Nel caso che la collezione di codici sia nulla o
     * vuota, non verrà eseguito la selezione per gruppi.
     * @return La lista di identificativi di risorse.
     */
    @Override
    public List&lt;String&gt; searchResourcesId(String type, String text, String categoryCode, Collection&lt;String&gt; groupCodes) {
<span class="nc" id="L246">        return this.searchResourcesId(type, text, null, categoryCode, groupCodes);</span>
    }
    
    @Override
    public List&lt;String&gt; searchResourcesId(String type, String text, String filename, String categoryCode, Collection&lt;String&gt; groupCodes) {
<span class="fc" id="L251">        FieldSearchFilter[] filters = this.createFilters(type, text, filename, groupCodes);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        List&lt;String&gt; categories = (StringUtils.isBlank(categoryCode)) ? null : Arrays.asList(categoryCode);</span>
<span class="fc" id="L253">        return this.searchResourcesId(filters, categories);</span>
    }

    private FieldSearchFilter[] createFilters(String type, String text, String filename, Collection&lt;String&gt; groupCodes) {
<span class="fc" id="L257">        FieldSearchFilter[] filters = new FieldSearchFilter[0];</span>
<span class="pc bpc" id="L258" title="1 of 4 branches missed.">        if (null != type &amp;&amp; type.trim().length() &gt; 0) {</span>
<span class="fc" id="L259">            FieldSearchFilter&lt;String&gt; filterToAdd = new FieldSearchFilter(IResourceManager.RESOURCE_TYPE_FILTER_KEY, type, false);</span>
<span class="fc" id="L260">            filters = super.addFilter(filters, filterToAdd);</span>
        }
<span class="fc bfc" id="L262" title="All 4 branches covered.">        if (null != text &amp;&amp; text.trim().length() &gt; 0) {</span>
<span class="fc" id="L263">            FieldSearchFilter&lt;String&gt; filterToAdd = new FieldSearchFilter(IResourceManager.RESOURCE_DESCR_FILTER_KEY, text, true);</span>
<span class="fc" id="L264">            filters = super.addFilter(filters, filterToAdd);</span>
        }
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">        if (null != filename &amp;&amp; filename.trim().length() &gt; 0) {</span>
<span class="fc" id="L267">            FieldSearchFilter&lt;String&gt; filterToAdd = new FieldSearchFilter(IResourceManager.RESOURCE_FILENAME_FILTER_KEY, filename, true);</span>
<span class="fc" id="L268">            filters = super.addFilter(filters, filterToAdd);</span>
        }
<span class="fc" id="L270">        filters = this.addGroupFilter(filters, groupCodes);</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (filters.length == 0) {</span>
<span class="fc" id="L272">            return null;</span>
        }
<span class="fc" id="L274">        return filters;</span>
    }

    private FieldSearchFilter[] addGroupFilter(FieldSearchFilter[] filters, Collection&lt;String&gt; groupCodes) {
<span class="pc bpc" id="L278" title="1 of 4 branches missed.">        if (groupCodes != null &amp;&amp; groupCodes.size() &gt; 0) {</span>
<span class="fc" id="L279">            List&lt;String&gt; allowedValues = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L280">            allowedValues.addAll(groupCodes);</span>
<span class="fc" id="L281">            FieldSearchFilter&lt;String&gt; filterToAdd = new FieldSearchFilter(IResourceManager.RESOURCE_MAIN_GROUP_FILTER_KEY, allowedValues, false);</span>
<span class="fc" id="L282">            filters = super.addFilter(filters, filterToAdd);</span>
        }
<span class="fc" id="L284">        return filters;</span>
    }

    @Override
    @Deprecated
    public List&lt;String&gt; searchResourcesId(FieldSearchFilter[] filters, String categoryCode, Collection&lt;String&gt; groupCodes) {
<span class="nc" id="L290">        filters = this.addGroupFilter(filters, groupCodes);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        List&lt;String&gt; categories = (StringUtils.isBlank(categoryCode)) ? null : Arrays.asList(categoryCode);</span>
<span class="nc" id="L292">        return this.searchResourcesId(filters, categories);</span>
    }
    
    @Override
    public List&lt;String&gt; searchResourcesId(FieldSearchFilter[] filters, List&lt;String&gt; categories, Collection&lt;String&gt; groupCodes) {
<span class="fc" id="L297">        filters = this.addGroupFilter(filters, groupCodes);</span>
<span class="fc" id="L298">        return this.searchResourcesId(filters, categories);</span>
    }

    @Override
    public Integer countResources(FieldSearchFilter[] filters, List&lt;String&gt; categories, Collection&lt;String&gt; groupCodes) {
<span class="fc" id="L303">        Connection conn = null;</span>
<span class="fc" id="L304">        int count = 0;</span>
<span class="fc" id="L305">        PreparedStatement stat = null;</span>
<span class="fc" id="L306">        ResultSet result = null;</span>
        try {
<span class="fc" id="L308">            conn = this.getConnection();</span>
<span class="fc" id="L309">            filters = this.addGroupFilter(filters, groupCodes);</span>
<span class="fc" id="L310">            stat = this.buildStatement(filters, categories, true, conn);</span>
<span class="fc" id="L311">            result = stat.executeQuery();</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            if (result.next()) {</span>
<span class="fc" id="L313">                count = result.getInt(1);</span>
            }
<span class="nc" id="L315">        } catch (Throwable t) {</span>
<span class="nc" id="L316">            logger.error(&quot;Error while loading the count of IDs&quot;, t);</span>
<span class="nc" id="L317">            throw new RuntimeException(&quot;Error while loading the count of IDs&quot;, t);</span>
        } finally {
<span class="fc" id="L319">            closeDaoResources(result, stat, conn);</span>
        }
<span class="fc" id="L321">        return count;</span>
    }
    
    @Override
    public List&lt;String&gt; searchResourcesId(FieldSearchFilter[] filters, List&lt;String&gt; categories) {
<span class="fc" id="L326">        Connection conn = null;</span>
<span class="fc" id="L327">        List&lt;String&gt; resources = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L328">        PreparedStatement stat = null;</span>
<span class="fc" id="L329">        ResultSet res = null;</span>
        try {
<span class="fc" id="L331">            conn = this.getConnection();</span>
<span class="fc" id="L332">            stat = this.buildStatement(filters, categories, false, conn);</span>
<span class="fc" id="L333">            res = stat.executeQuery();</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">            while (res.next()) {</span>
<span class="fc" id="L335">                String id = res.getString(this.getMasterTableIdFieldName());</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                if (!resources.contains(id)) {</span>
<span class="fc" id="L337">                    resources.add(id);</span>
                }
<span class="fc" id="L339">            }</span>
<span class="nc" id="L340">        } catch (Throwable t) {</span>
<span class="nc" id="L341">            logger.error(&quot;Error loading resources id&quot;, t);</span>
<span class="nc" id="L342">            throw new RuntimeException(&quot;Error loading resources id&quot;, t);</span>
        } finally {
<span class="fc" id="L344">            closeDaoResources(res, stat, conn);</span>
        }
<span class="fc" id="L346">        return resources;</span>
    }

    private PreparedStatement buildStatement(FieldSearchFilter[] filters, List&lt;String&gt; categories, boolean isCount, Connection conn) {
<span class="fc" id="L350">        String query = this.createQueryString(filters, categories, isCount);</span>
<span class="fc" id="L351">        PreparedStatement stat = null;</span>
        try {
<span class="fc" id="L353">            stat = conn.prepareStatement(query);</span>
<span class="fc" id="L354">            int index = 0;</span>
<span class="fc bfc" id="L355" title="All 4 branches covered.">            if (null != categories &amp;&amp; categories.size() &gt; 0) {</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">                for (String category : categories) {</span>
<span class="fc" id="L357">                    stat.setString(++index, category);</span>
<span class="fc" id="L358">                }</span>
            }
<span class="fc" id="L360">            index = this.addMetadataFieldFilterStatementBlock(filters, index, stat);</span>
<span class="nc" id="L361">        } catch (Throwable t) {</span>
<span class="nc" id="L362">            logger.error(&quot;Error while creating the statement&quot;, t);</span>
<span class="nc" id="L363">            throw new RuntimeException(&quot;Error while creating the statement&quot;, t);</span>
<span class="fc" id="L364">        }</span>
<span class="fc" id="L365">        return stat;</span>
    }

    private String createQueryString(FieldSearchFilter[] filters, List&lt;String&gt; categories, boolean isCount) {
<span class="fc" id="L369">        StringBuffer query = this.createBaseQueryBlock(filters, false, isCount, categories);</span>
<span class="fc" id="L370">        this.appendMetadataFieldFilterQueryBlocks(filters, query, false);</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">        if (!isCount) {</span>
<span class="fc" id="L372">            super.appendOrderQueryBlocks(filters, query, false);</span>
<span class="fc" id="L373">            this.appendLimitQueryBlock(filters, query);</span>
        }
<span class="fc" id="L375">        return query.toString();</span>
    }

    private StringBuffer createBaseQueryBlock(FieldSearchFilter[] filters, boolean selectAll, boolean isCount, List&lt;String&gt; categories) {
<span class="fc" id="L379">        StringBuffer query = super.createBaseQueryBlock(filters, isCount, selectAll);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (categories != null) {</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">            for (int i = 0; i &lt; categories.size(); i++) {</span>
<span class="fc" id="L382">                query.append(String.format(</span>
                        &quot;INNER JOIN resourcerelations res%d ON resources.resid = res%d.resid AND res%d.refcategory= ? &quot;,
<span class="fc" id="L384">                        i, i, i));</span>
            }
        }
<span class="fc" id="L387">        return query;</span>
    }

    /**
     * Carica un record di risorse in funzione dell'id Risorsa. Questo record è
     * necessario per l'estrazione della risorse in oggetto tipo
     * AbstractResource da parte del ResourceManager.
     *
     * @param id L'identificativo della risorsa.
     * @return Il record della risorsa.
     */
    @Override
    @Cacheable(value = ICacheInfoManager.DEFAULT_CACHE_NAME, key = &quot;'jacms_resource_'.concat(#id)&quot;, condition = &quot;null != #id and null != #result&quot;)
    public ResourceRecordVO loadResourceVo(String id) {
<span class="fc" id="L401">        Connection conn = null;</span>
<span class="fc" id="L402">        ResourceRecordVO resourceVo = null;</span>
<span class="fc" id="L403">        PreparedStatement stat = null;</span>
<span class="fc" id="L404">        ResultSet res = null;</span>
        try {
<span class="fc" id="L406">            conn = this.getConnection();</span>
<span class="fc" id="L407">            stat = conn.prepareStatement(LOAD_RESOURCE_VO);</span>
<span class="fc" id="L408">            stat.setString(1, id);</span>
<span class="fc" id="L409">            res = stat.executeQuery();</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">            if (res.next()) {</span>
<span class="fc" id="L411">                resourceVo = new ResourceRecordVO();</span>
<span class="fc" id="L412">                resourceVo.setId(id);</span>
<span class="fc" id="L413">                resourceVo.setResourceType(res.getString(1));</span>
<span class="fc" id="L414">                resourceVo.setDescr(res.getString(2));</span>
<span class="fc" id="L415">                resourceVo.setMainGroup(res.getString(3));</span>
<span class="fc" id="L416">                resourceVo.setXml(res.getString(4));</span>
<span class="fc" id="L417">                resourceVo.setMasterFileName(res.getString(5));</span>
<span class="fc" id="L418">                resourceVo.setCreationDate(res.getTimestamp(6));</span>
<span class="fc" id="L419">                resourceVo.setLastModified(res.getTimestamp(7));</span>
<span class="fc" id="L420">                resourceVo.setOwner(res.getString(8));</span>
<span class="fc" id="L421">                resourceVo.setFolderPath(res.getString(9));</span>
            }
<span class="nc" id="L423">        } catch (Exception t) {</span>
<span class="nc" id="L424">            logger.error(&quot;Errore loading resource {}&quot;, id, t);</span>
<span class="nc" id="L425">            throw new RuntimeException(&quot;Errore loading resource&quot; + id, t);</span>
        } finally {
<span class="fc" id="L427">            closeDaoResources(res, stat, conn);</span>
        }
<span class="fc" id="L429">        return resourceVo;</span>
    }

    /**
     * Metodo di servizio. Aggiunge un record nella tabella resourcerelations
     * per ogni categoria della risorsa.
     *
     * @param resource La risorsa del quale referenziare le categorie.
     * @param conn La connessione con il db.
     * @throws EntException
     */
    protected void addCategoryRelationsRecord(ResourceInterface resource, Connection conn) throws EntException {
<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (resource.getCategories().size() &gt; 0) {</span>
<span class="fc" id="L442">            PreparedStatement stat = null;</span>
            try {
<span class="fc" id="L444">                Set&lt;String&gt; codes = this.getCategoryCodes(resource);</span>
<span class="fc" id="L445">                stat = conn.prepareStatement(ADD_RESOURCE_REL_RECORD);</span>
<span class="fc" id="L446">                Iterator&lt;String&gt; codeIter = codes.iterator();</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">                while (codeIter.hasNext()) {</span>
<span class="fc" id="L448">                    String code = (String) codeIter.next();</span>
<span class="fc" id="L449">                    stat.setString(1, resource.getId());</span>
<span class="fc" id="L450">                    stat.setString(2, code);</span>
<span class="fc" id="L451">                    stat.addBatch();</span>
<span class="fc" id="L452">                    stat.clearParameters();</span>
<span class="fc" id="L453">                }</span>
<span class="fc" id="L454">                stat.executeBatch();</span>
<span class="nc" id="L455">            } catch (Exception t) {</span>
<span class="nc" id="L456">                logger.error(&quot;Error adding resourcerelations record for {}&quot;, resource.getId(), t);</span>
<span class="nc" id="L457">                throw new RuntimeException(&quot;Error adding resourcerelations record for &quot; + resource.getId(), t);</span>
            } finally {
<span class="fc" id="L459">                closeDaoResources(null, stat);</span>
            }
        }
<span class="fc" id="L462">    }</span>

    /**
     * Restituisce la lista di codici di categorie associate ad una risorsa. La
     * risorsa viene sempre referenziata con la categoria &quot;root&quot; della tipologia
     * relativa (che corrisponde al codice della tipologia).
     *
     * @param resource La risorsa da inserire o da modificare.
     * @return Il set di codici di categorie.
     */
    private Set&lt;String&gt; getCategoryCodes(ResourceInterface resource) {
<span class="fc" id="L473">        Set&lt;String&gt; codes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L474">        Iterator&lt;Category&gt; categoryIter = resource.getCategories().iterator();</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">        while (categoryIter.hasNext()) {</span>
<span class="fc" id="L476">            Category category = (Category) categoryIter.next();</span>
<span class="fc" id="L477">            this.addCategoryCode(resource, category, codes);</span>
<span class="fc" id="L478">        }</span>
<span class="fc" id="L479">        return codes;</span>
    }

    private void addCategoryCode(ResourceInterface resource, Category category, Set&lt;String&gt; codes) {
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (category.getCode().equals(category.getParentCode())) {</span>
<span class="fc" id="L484">            return;</span>
        }
<span class="fc" id="L486">        codes.add(category.getCode());</span>
<span class="fc" id="L487">        Category parentCategory = this.getCategoryManager().getCategory(category.getParentCode());</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">        if (null != parentCategory) {</span>
<span class="fc" id="L489">            this.addCategoryCode(resource, parentCategory, codes);</span>
        }
<span class="fc" id="L491">    }</span>
    
    protected void deleteRecordsById(String resourceId, String query, Connection conn) {
<span class="fc" id="L494">        super.executeQueryWithoutResultset(conn, query, resourceId);</span>
<span class="fc" id="L495">    }</span>
    
    /* ESTENSIONE SPOSTAMENTO NODI */
    @Override
    public void updateResourceRelations(ResourceInterface resource) {
<span class="nc" id="L500">        Connection conn = null;</span>
        try {
<span class="nc" id="L502">            conn = this.getConnection();</span>
<span class="nc" id="L503">            conn.setAutoCommit(false);</span>
<span class="nc" id="L504">            this.deleteRecordsById(resource.getId(), DELETE_RESOURCE_REL_RECORD, conn);</span>
<span class="nc" id="L505">            this.addCategoryRelationsRecord(resource, conn);</span>
<span class="nc" id="L506">            conn.commit();</span>
<span class="nc" id="L507">        } catch (Exception t) {</span>
<span class="nc" id="L508">            this.executeRollback(conn);</span>
<span class="nc" id="L509">            this.processDaoException(t, &quot;Error updating resource category relations&quot;, &quot;updateResourceRelations&quot;);</span>
        } finally {
<span class="nc" id="L511">            closeConnection(conn);</span>
        }
<span class="nc" id="L513">    }</span>

    @Override
    protected String getMasterTableName() {
<span class="fc" id="L517">        return &quot;resources&quot;;</span>
    }

    @Override
    protected String getMasterTableIdFieldName() {
<span class="fc" id="L522">        return &quot;resid&quot;;</span>
    }

    @Override
    protected String getTableFieldName(String metadataFieldKey) {
<span class="fc" id="L527">        return metadataFieldKey;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>